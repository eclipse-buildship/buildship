apply plugin: eclipsebuild.UpdateSitePlugin
apply plugin: 'org.hidetake.ssh'

buildscript {
    repositories { jcenter() }
    dependencies { classpath 'org.hidetake:gradle-ssh-plugin:1.1.2' }
}

updateSite {
    extraResources = files('epl-v10.html', 'notice.html', 'p2.index')
    p2ExtraProperties = collectP2ExtraProperties()
    signing { folders ->
        // if the created update site is going to be published remotely, replace the local signing with the one available on eclipse.org
        if (gradle.taskGraph.hasTask(uploadUpdateSite)) {
            ssh.run {
                session(remotes.eclipseDotOrg) {
                    // the remote folder where the jars are signed
                    def remoteFolder = "${ECLIPSE_ORG_TEMP_PATH}/${folders.signedFolder.name}"

                    // clean up the folder used for signing if the previous build failed
                    execute """rm -rf $remoteFolder
                    mkdir -p $remoteFolder"""

                    // transfer the unsigned files to the remote host
                    put from: file(folders.unsignedFolder).listFiles() as List, into: remoteFolder

                    // perform the signing
                    execute """ cd $remoteFolder
                    # iterate all jars in the subfolders
                    for jar in \$(find `pwd` -name '*.jar');
                    do
                        # save the signed jar into a temporary file copy and write it's content to the unsigned jar
                        curl -o signed.jar -F filedata=@\$jar http://build.eclipse.org:31338/sign
                        cp signed.jar \$jar
                        rm signed.jar
                    done
                    """

                    // retrieve the signed content from the remote host into the build/signed-bundles folder
                    get from: remoteFolder, into: folders.signedFolder.parentFile

                    // clean up the remote folder
                    execute "rm -rf $remoteFolder"
                }
            }
        } else {
            def unsignedPluginsDir = new File(folders.unsignedFolder, "plugins")
            def unsignedFeaturesDir = new File(folders.unsignedFolder, "features")
            def signedPluginsDir = new File(folders.signedFolder, "plugins")
            def signedFeaturesDir = new File(folders.signedFolder, "features")

            signedPluginsDir.mkdirs()
            signedFeaturesDir.mkdirs()

            File targetDir = signedPluginsDir
            def signBundle = {
                project.logger.info("Sign '${it.absolutePath}'")
                project.ant.signjar(
                    verbose: 'true',
                    destDir: targetDir,
                    alias: 'EclipsePlugins',
                    jar: it,
                    keystore: project.findProject(':').file('gradle/config/signing/DevKeystore.ks'),
                    storepass: 'tooling',
                    keypass: 'tooling',
                    sigalg: 'SHA1withDSA',
                    digestalg: 'SHA1',
                    preservelastmodified: 'true')
            }

            unsignedPluginsDir.listFiles().each signBundle
            targetDir = signedFeaturesDir
            unsignedFeaturesDir.listFiles().each signBundle
        }
    }
}

remotes {
    eclipseDotOrg {
        host = ECLIPSE_ORG_FTP_HOST
        user =  ECLIPSE_ORG_FTP_USER
        password = ECLIPSE_ORG_FTP_PASSWORD
        knownHosts = project.rootProject.file('gradle/ssh/known_hosts')
    }
}

dependencies {
    localPlugin project(':org.eclipse.buildship.core')
    localPlugin project(':org.eclipse.buildship.ui')
    localPlugin project(':org.eclipse.buildship.branding')
    localFeature project(':org.eclipse.buildship.feature')

    // include 3rd party dependencies in the update site
    externalPlugin withEclipseBundle('com.gradleware.tooling.utils')
    externalPlugin withEclipseBundle('com.gradleware.tooling.client')
    externalPlugin withEclipseBundle('com.gradleware.tooling.model')
    externalPlugin withEclipseBundle('org.gradle.toolingapi')
    externalPlugin withEclipseBundle('org.slf4j.api')
    externalPlugin withEclipseBundle('org.slf4j.simple')
    externalPlugin withEclipseBundle('com.google.guava')

    // official 3rd party dependencies from Orbit which are already signed and normalized with pack200
    signedExternalPlugin withEclipseBundle('com.google.gson')
}

task uploadUpdateSite(dependsOn : createP2Repository) {
    description = "Uploads the generated update site to the eclipse.org server."

    doLast {
        // folder structure
        // releases                    (main folder - composite update site if release repository)
        //  |--1.0                     (version folder - always a composite update site)
        //     |--1.0.0.v20150413-1512 (repository folder - simple update site)

        // define the folder structure
        def releaseTypeFolder = "${ECLIPSE_ORG_FTP_UPDATE_SITES_PATH}/${releaseTypeFolder(project)}"
        def versionFolder = "${releaseTypeFolder}/${releaseVersion()}"
        def repositoryFolder = "${versionFolder}/${project.version}"

        // create composite update site for the root of the release repository and for the versions folder
        def config = eclipsebuild.BuildshipConfig.on(project)
        def compositeFolders = config.isRelease() ? [releaseTypeFolder, versionFolder]: [versionFolder]

        // upload the update site and update the composite descriptors
        ssh.run {
            session(remotes.eclipseDotOrg) {
                // create the leaf directory if not exist
                execute "mkdir -p $repositoryFolder"

                // copy the update site from the build directory to the remote location
                put from: files { file("$buildDir/repository").listFiles() }, into: repositoryFolder

                // recreate the compositeArtifacts.jar and the compositeContent.jar files
                compositeFolders.each { execute("""cd ${it}
                      ${file('updateCompositeUpdateSite.sh').text}""") }
            }
        }
    }
}

// utility methods

def collectP2ExtraProperties() {
    if (ECLIPSE_ORG_MIRROR_PATH) {
        ['p2.mirrorsURL': calculateP2MirrorsUrl(project)]
    } else {
        [:]
    }
}

def calculateP2MirrorsUrl(Project project) {
    def repositoryPath = "${ECLIPSE_ORG_MIRROR_PATH}/${releaseTypeFolder(project)}/${releaseVersion()}/${project.version}"
    "http://www.eclipse.org/downloads/download.php?file=${repositoryPath}&format=xml"
}

def releaseTypeFolder(Project project) {
    def config = eclipsebuild.BuildshipConfig.on(project)
    if(config.isRelease()) {
        "releases"
    } else if(config.isMilestone()){
        "milestones"
    } else if(config.isSnapshot()) {
        "snapshots"
    } else {
        throw new IllegalStateException("BuildshipConfig must either be a release, milestone, or snapshot.")
    }
}

def releaseVersion() {
    // crop the major.minor segment from the version number
    def matcher = version =~ /(\d+\.\d+)\.\d+\..*/
    matcher[0][1]
}
