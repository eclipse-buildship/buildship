/*
 * Copyright (c) 2015 the original author or authors.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Simon Scholz (vogella GmbH) - initial API and implementation and initial documentation
 */

package org.eclipse.buildship.ui.view.execution;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

import org.gradle.tooling.events.OperationDescriptor;
import org.gradle.tooling.events.test.JvmTestOperationDescriptor;
import org.osgi.framework.Bundle;
import org.osgi.framework.FrameworkUtil;

import com.google.common.collect.ImmutableList;

import org.eclipse.core.resources.IWorkspaceRoot;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Status;
import org.eclipse.core.runtime.jobs.Job;
import org.eclipse.jdt.core.IAnnotation;
import org.eclipse.jdt.core.IJavaElement;
import org.eclipse.jdt.core.IMethod;
import org.eclipse.jdt.core.IType;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.jdt.core.search.IJavaSearchConstants;
import org.eclipse.jdt.core.search.IJavaSearchScope;
import org.eclipse.jdt.core.search.SearchEngine;
import org.eclipse.jdt.core.search.SearchMatch;
import org.eclipse.jdt.core.search.SearchParticipant;
import org.eclipse.jdt.core.search.SearchPattern;
import org.eclipse.jdt.core.search.SearchRequestor;
import org.eclipse.jdt.internal.corext.util.JavaConventionsUtil;
import org.eclipse.jdt.ui.JavaUI;
import org.eclipse.swt.widgets.Display;
import org.eclipse.ui.PartInitException;
import org.eclipse.ui.PlatformUI;

import org.eclipse.buildship.ui.UiPlugin;

/**
 * Opens the test source files for the given
 * {@link org.eclipse.buildship.ui.view.execution.OperationItem} test nodes.
 */
@SuppressWarnings("restriction")
public final class OpenTestSourceFileJob extends Job {

    private final ImmutableList<OperationItem> operationItems;
    private final AtomicBoolean foundJavaElement;

    public OpenTestSourceFileJob(List<OperationItem> operationItems) {
        super("Opening test source files");
        this.operationItems = ImmutableList.copyOf(operationItems);
        this.foundJavaElement = new AtomicBoolean(false);
    }

    @Override
    protected IStatus run(IProgressMonitor monitor) {
        for (OperationItem operationItem : this.operationItems) {
            OperationDescriptor operationDescriptor = (OperationDescriptor) operationItem.getAdapter(OperationDescriptor.class);
            if (operationDescriptor instanceof JvmTestOperationDescriptor) {
                JvmTestOperationDescriptor testOperationDescriptor = (JvmTestOperationDescriptor) operationDescriptor;
                String className = testOperationDescriptor.getClassName();
                if (className != null) {
                    String methodName = testOperationDescriptor.getMethodName();
                    IStatus status = searchForTestSource(monitor, className, methodName);
                    if (!status.isOK()) {
                        return status;
                    }
                }
            }
        }
        return Status.OK_STATUS;
    }

    private IStatus searchForTestSource(IProgressMonitor monitor, final String className, final String methodName) {
        try {
            SearchEngine searchEngine = new SearchEngine();
            IJavaSearchScope workspaceScope = SearchEngine.createWorkspaceScope();
            SearchPattern pattern = SearchPattern.createPattern(className, IJavaSearchConstants.TYPE, IJavaSearchConstants.DECLARATIONS, SearchPattern.R_EXACT_MATCH);
            SearchRequestor requester = new SearchRequestor() {

                @Override
                public void acceptSearchMatch(SearchMatch match) throws CoreException {
                    if (match.getElement() instanceof IType) {
                        IType type = (IType) match.getElement();
                        final IJavaElement javaElement = findMethod(type, methodName);
                        if (javaElement != null) {
                            OpenTestSourceFileJob.this.foundJavaElement.set(true);
                            Display display = PlatformUI.getWorkbench().getDisplay();
                            display.asyncExec(new Runnable() {

                                @Override
                                public void run() {
                                    try {
                                        JavaUI.openInEditor(javaElement);
                                    } catch (PartInitException e) {
                                        UiPlugin.logger().error(e.getMessage(), e);
                                    } catch (JavaModelException e) {
                                        UiPlugin.logger().error(e.getMessage(), e);
                                    }
                                }
                            });
                        }
                    }
                }
            };
            searchEngine.search(pattern, new SearchParticipant[]{SearchEngine.getDefaultSearchParticipant()}, workspaceScope, requester, monitor);

            // find class and method in .groovy files, if no java element has been found
            if (!this.foundJavaElement.get()) {
                IWorkspaceRoot workspaceRoot = ResourcesPlugin.getWorkspace().getRoot();
                workspaceRoot.accept(new TestResourceVisitor(className, methodName, Collections.singleton("groovy"))); //$NON-NLS-1$
            }
        } catch (CoreException e) {
            UiPlugin.logger().error(e.getMessage(), e);
            Bundle bundle = FrameworkUtil.getBundle(getClass());
            return new Status(Status.ERROR, bundle.getSymbolicName(), e.getMessage(), e);
        }

        return Status.OK_STATUS;
    }

    /**
     * Copy of org.eclipse.jdt.internal.junit.ui.OpenTestAction.findMethod(IType).
     */
    private IJavaElement findMethod(IType type, String methodName) {
        IStatus status = JavaConventionsUtil.validateMethodName(methodName, type);
        if (!status.isOK()) {
            return type;
        }

        IMethod method = type.getMethod(methodName, new String[0]);
        if (method != null && method.exists()) {
            return method;
        }

        // search just by name, if method not found yet (for custom runner with test methods having
        // parameters)
        try {
            List<IMethod> foundMethods = new ArrayList<IMethod>();
            for (IMethod methodItem : type.getMethods()) {
                String methodItemName = methodItem.getElementName();
                IAnnotation methodAnnotation = methodItem.getAnnotation("Test"); //$NON-NLS-1$

                // JUnit3 test method starts with "test" or JUnit4 test method is annotated with "@Test"
                if ((methodItemName.startsWith("test") || (methodAnnotation != null && methodAnnotation.exists()))) {
                    foundMethods.add(methodItem);
                }
            }
            if (foundMethods.isEmpty()) {
                return type;
            } else {
                return foundMethods.get(0);
            }
        } catch (JavaModelException e) {
            // if type does not exist or if an exception occurs while accessing its resource =>
            // ignore (no method found)
        }

        return type;
    }

}
